FUNCTION_BLOCK "fbTrackingRegulator"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Heaten
VERSION : 0.1
   VAR_INPUT 
      bEnable : Bool;
      bReset : Bool;
      sSP : "stCalcValue";   // Setpoint
      sPV : "stCalcValue";   // Process value
      sVelocity : "stCalcValue";   // Process value velocity
      fCycleTime : Real;
   END_VAR

   VAR_OUTPUT 
      fOut : Real;
      bAtMin : Bool;
      bAtMax : Bool;
   END_VAR

   VAR_IN_OUT 
      sTag : "stTrackingRegulator";
   END_VAR

   VAR 
      fStepsizePositive : Real;   // Output increment
      fStepsizeNegative : Real;   // Output decrement
   END_VAR

   VAR_TEMP 
      Enabled : Bool;
   END_VAR


BEGIN
	// Tracking regulator, a varaint of incremental control
	// Based on the "tracking ADC" algorithm, also known as "delta-encoded" or "counter-ramp"
	// The main parameters are the positive and negative slew rates. These control how big the increment in the output is.
	// The output is a staircase waveform which ramps the actuator up and down. The step size is calculated from the slew rate and cycle time.
	// There are two rates: the rate of change of the process value, and the rate of change of the actuator
	// For example, limiting the slew rate of a valve to keep the temperature increase below a limit
	
	// Detailed algorithm:
	// IF temperature < target AND temperature rate of change < positive limit THEN
	//    Increase valve output by positive step size
	// ELSIF temperature > target OR temperature rate of change > positive limit THEN
	//    Decrease valve output by negative step size
	// ELSE
	//    Keep valve output the same
	// END_IF
	// 
	
	// Tuning procedure:
	// 1. Set the fSlewRatePositive to something conservative like 0.2C/s
	// 2. Start HB and let it get to State 2
	// 3. Watch the heating of the steam condensers
	// 4. If the heating is very slow....
	
	// Copy to tag
	#sTag.fPV := #sPV.fValue;
	#sTag.fSP := #sSP.fValue;
	#sTag.fPVvelocity := #sVelocity.fValue;
	
	IF #bReset = TRUE THEN
	    #sTag.fOut := 0.0;
	    #sTag.bManualMode := FALSE;
	    #sTag.fManualValue := 0.0;
	END_IF;
	
	#Enabled := (#bEnable AND #sTag.bEnable) OR #sTag.bManualMode;
	
	// Step sizes
	#fStepsizePositive := #sTag.fSlewRatePositive / #fCycleTime;
	#fStepsizeNegative := #sTag.fSlewRateNegative / #fCycleTime;
	
	// Controller fault
	#sTag.bFault := #sSP.bError OR #sPV.bError OR #sVelocity.bError;
	
	IF #sTag.bManualMode = TRUE THEN
	    // Manual mode
	    #sTag.fOut := #sTag.fManualValue;
	ELSE
	    // Auto mode
	    IF #sPV.fValue < (#sSP.fValue - #sTag.fHysteresis) AND #sVelocity.fValue < #sTag.fVelocityPositiveLimit THEN
	        // Increase valve output
	        #sTag.fOut := #sTag.fOut + #fStepsizePositive;
	        #sTag.bAtSetpoint := FALSE;
	    ELSIF #sPV.fValue > (#sSP.fValue + #sTag.fHysteresis) OR #sVelocity.fValue > #sTag.fVelocityPositiveLimit THEN
	        // Decrease valve output
	        #sTag.fOut := #sTag.fOut - #fStepsizeNegative;
	        #sTag.bAtSetpoint := FALSE;
	    ELSE
	        // Keep valve output the same. Dummy branch but important to see the flow
	        #sTag.fOut := #sTag.fOut;
	        #sTag.bAtSetpoint := TRUE;
	    END_IF;
	END_IF;
	
	// Post processing
	IF #Enabled = FALSE OR #sTag.bFault = TRUE THEN
	    #sTag.fOut := 0.0;
	    #sTag.bAtMin := FALSE;
	    #sTag.bAtMax := FALSE;
	ELSE
	    //Evaluate limits exceeded first...
	    #sTag.bAtMin := NOT (#sTag.fOut > #sTag.fOutMin);
	    #sTag.bAtMax := #sTag.fOut >= #sTag.fOutMax;
	    //...before doing the actual limiting
	    #sTag.fOut := LIMIT(MN := #sTag.fOutMin, IN := #sTag.fOut, MX := #sTag.fOutMax);
	END_IF;
	
	// Mode
	IF #sTag.bManualMode = TRUE THEN
	    #sTag.nMode := 2;
	ELSIF #sTag.bEnable = TRUE THEN
	    #sTag.nMode := 1;
	ELSE
	    #sTag.nMode := 0;
	END_IF;
	
	// Local outputs
	#fOut := #sTag.fOut;
	#bAtMin := #sTag.bAtMin;
	#bAtMax := #sTag.bAtMax;
	
	
END_FUNCTION_BLOCK

