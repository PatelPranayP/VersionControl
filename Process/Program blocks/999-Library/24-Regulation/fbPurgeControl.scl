FUNCTION_BLOCK "fbPurgeControl"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Heaten
VERSION : 0.1
   VAR_INPUT 
      bEnable : Bool;   // 1 = enable, 0 = disable
      bRotationStopped : Bool;   // 1 = rotation stopped, 0 = rotating
      DeltaP : "stCalcValue";   // [kPa] 
      Speed : "stCalcValue";   // [rpm]
      fCycleTime : Real;
   END_VAR

   VAR_OUTPUT 
      bPurging : Bool;
      bSpinning : Bool;
      bDone : Bool := false;
   END_VAR

   VAR_IN_OUT 
      sTag : "stPurgeControl";
   END_VAR

   VAR 
      nState : Int;   // 0 = Idle, 1 = Purge, 2 = Ramp up, 3 = Spin, 4 = Ramp down, 5 = Reset
      PurgeTimer {InstructionName := 'TON_TIME'; LibVersion := '1.0'; S7_SetPoint := 'False'} : TON_TIME;   // How long to purge for
      SpinTimer {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;   // How long to spin for
      PumpStartTimer {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;   // How long to wait for the pump to start & generate pressure
      tRamp : Time;   // Time to ramp up to spin speed
      tSpin : Time;   // Time at full spin speed
      Start {InstructionName := 'R_TRIG'; LibVersion := '1.0'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR

   VAR_TEMP 
      bEnabled : Bool;
   END_VAR

   VAR CONSTANT 
      PrimingDelay : Time := T#4s;
   END_VAR


BEGIN
	// Purge controller
	// Run a compressor purge cycle:
	// 1. Repeat x times: (where x can be zero)
	//    a. Drain the suction manifold. Either for a certain amount of time, or look at the deltaP over the pump
	//    b. Spin the compressor to get the suction line to barf up a slug of liquid, with configurable ramp, speed and duration
	// 2. Drain the suction manifold. Either for a certain amount of time, or look at the deltaP over the pump
	// 3. bDone = TRUE
	// NOTE: "look at the deltaP over the pump" means run the pump for #PrimingDelay, then continue as long as pump delta P is not less than 
	// sTag.Purge.fPurgeDeltaP
	
	// Enable. Edge trigger to run it only once. bReset is like a momentary disable
	#bEnabled := #bEnable AND #sTag.bEnable AND NOT #sTag.bReset;
	#Start(CLK := #bEnable AND #sTag.bEnable);
	
	// Be quiet when not in operation
	IF #bEnabled = FALSE THEN
	    #sTag.bDone := FALSE;
	END_IF;
	
	// Run timers outside of the state machine so they run & reset properly
	#PurgeTimer(IN := (#nState = 1 OR #nState = 6), PT := #sTag.Purge.tPurgeTime);
	#SpinTimer(IN := (#nState = 3), PT := #tSpin);
	#PumpStartTimer(IN := ((#nState = 1 OR #nState = 6) AND #sTag.Purge.nPurgeType = 1), PT := #PrimingDelay);
	
	// Purge sequencer
	CASE #nState OF
	    0: // Idle
	        IF #Start.Q = TRUE THEN
	            IF #sTag.nPurgeCycles = 0 THEN
	                #nState := 6;
	            ELSE
	                #sTag.nPurgeCyclesRemaining := #sTag.nPurgeCycles;
	                #sTag.bDone := FALSE;
	                #tRamp := UDINT_TO_TIME(REAL_TO_UDINT((#sTag.Spin.fSpinSpeed/#sTag.Spin.fSpinRamp)*1000));
	                #tSpin := #sTag.Spin.tSpinTime - 2 * #tRamp;
	                #nState := 1;
	            END_IF;
	        END_IF;
	    1: // Purge
	        IF #bEnabled = FALSE THEN
	            #nState := 5;
	        ELSE
	            // Start purging
	            #sTag.bPurging := TRUE;
	            // Decide when to stop
	            IF #sTag.Purge.nPurgeType = 0 THEN
	                // Timer
	                IF #PurgeTimer.Q = TRUE THEN
	                    #sTag.bPurging := FALSE;
	                    #nState := 2;
	                END_IF;
	            ELSIF #sTag.Purge.nPurgeType = 1 THEN
	                // Delta P
	                IF #PumpStartTimer.Q AND (#DeltaP.fValue < #sTag.Purge.fPurgeDeltaP) THEN
	                    #sTag.bPurging := FALSE;
	                    #nState := 2;
	                END_IF;
	            END_IF;
	        END_IF;
	    2: // Ramp Up
	        "RampLimiter"(InputValue            := #sTag.Spin.fSpinSpeed,                                  
	                      "PositivChange per_s" := #sTag.Spin.fSpinRamp,
	                      "NegativChange per_s" := -#sTag.Spin.fSpinRamp,
	                      fCycleTime            := #fCycleTime,
	                      OutputValue           := #sTag.fSpinOut);
	        IF #bEnabled = FALSE THEN
	            #nState := 5;
	        ELSIF #Speed.fValue > #sTag.Spin.fSpinSpeed - 5 THEN
	            #nState := 3;
	        END_IF;
	    3: // Spin
	        IF #bEnabled = FALSE THEN
	            #nState := 5;
	        ELSIF #SpinTimer.Q = TRUE THEN
	            #nState := 4;
	        END_IF;
	    4: // Ramp down
	        "RampLimiter"(InputValue            := 0.0,                         
	                      "PositivChange per_s" := #sTag.Spin.fSpinRamp,
	                      "NegativChange per_s" := -#sTag.Spin.fSpinRamp,
	                      fCycleTime            := #fCycleTime,
	                      OutputValue           := #sTag.fSpinOut);
	        IF #bEnabled = FALSE THEN
	            #nState := 5;
	        ELSIF #bRotationStopped = TRUE THEN
	            #sTag.fSpinOut := 0;
	            #sTag.nPurgeCyclesRemaining := #sTag.nPurgeCyclesRemaining - 1;
	            IF #sTag.nPurgeCyclesRemaining = 0 THEN
	                #nState := 6;
	            ELSE
	                #nState := 1;
	            END_IF;
	        END_IF;
	    5: // Reset
	        #sTag.nPurgeCyclesRemaining := 0;
	        #sTag.bPurging := FALSE;
	        #sTag.fSpinOut := 0;
	        #sTag.bDone := TRUE;
	        #nState := 0;
	    6: // Last purge
	        IF #bEnabled = FALSE THEN
	            #nState := 5;
	        ELSE
	            // Start purging
	            #sTag.bPurging := TRUE;
	            // Decide when to stop
	            IF #sTag.Purge.nPurgeType = 0 THEN
	                // Timer
	                IF #PurgeTimer.Q = TRUE THEN
	                    #sTag.bPurging := FALSE;
	                    #nState := 5;
	                END_IF;
	            ELSIF #sTag.Purge.nPurgeType = 1 THEN
	                // Delta P
	                IF #PumpStartTimer.Q AND (#DeltaP.fValue < #sTag.Purge.fPurgeDeltaP) THEN
	                    #sTag.bPurging := FALSE;
	                    #nState := 5;
	                END_IF;
	            END_IF;
	        END_IF;
	END_CASE;
	
	// Mode
	IF #sTag.bEnable = TRUE THEN
	    #sTag.nMode := 1;
	ELSE
	    #sTag.nMode := 0;
	END_IF;
	
	// Local outputs     
	#bDone := #sTag.bDone;
	#bPurging := #sTag.bPurging;
	#bSpinning := #sTag.bSpinning := (#nState = 2 OR #nState = 3 OR #nState = 4);
END_FUNCTION_BLOCK

