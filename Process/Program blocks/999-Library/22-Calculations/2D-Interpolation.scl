FUNCTION "2D-Interpolation" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      x_in : Real;
      y_in : Real;
   END_VAR

   VAR_OUTPUT 
      f_out : Real;
   END_VAR

   VAR_IN_OUT 
      X_Array : Array[*] of Real;
      Y_Array : Array[*] of Real;
      F_Array : Array[*, *] of Real;
   END_VAR

   VAR_TEMP 
      Xindex_L : DInt;
      Xindex_U : DInt;
      Yindex_L : DInt;
      Yindex_U : DInt;
      X_L : Real;
      X_H : Real;
      Y_L : Real;
      Y_H : Real;
      F_LxLy : Real;
      F_LxHy : Real;
      F_HxLy : Real;
      F_HxHy : Real;
      x : Real;
      y : Real;
   END_VAR


BEGIN
	#x := #x_in;
	#y := #y_in;
	
	"FindIndex"(x:=#x,
	            index_L=>#Xindex_L,
	            Array:=#X_Array);
	"FindIndex"(x:=#y,
	            index_L=>#Yindex_L,
	            Array:=#Y_Array);
	(* REGION Find nearest meshpoint (#Y_Array[#Xindex_L]) smaller than x
	    // If x is closest to the last index (Count_Xi) or lies beyond, then take the second last index anyway
	    // We use our previous result from last calculation (#LastXi) as startpoint for the search
	    #Xindex_L := #LastXi;
	    IF #Xindex_L > 0 AND #x < #X_Array[#Xindex_L] THEN
	        //Suche nach links (kleinere indizes)
	        WHILE #Xindex_L > 0 AND #x < #X_Array[#Xindex_L - 1] DO
	            #Xindex_L -= 1;
	            IF #Xindex_L = 0 THEN
	                EXIT;
	            END_IF;
	        END_WHILE;
	    ELSE
	        //Suche nach rechts (größere indizes)
	        WHILE #Xindex_L < (#Count_Xi - 1) AND #x > #X_Array[#Xindex_L + 1] DO
	            #Xindex_L += 1;
	        END_WHILE;
	    END_IF;
	END_REGION
	REGION Find nearest meshpoint (#Y_Array[#Yindex_L]) smaller than y
	    // If y is closest to the last index (count_Yi) or lies beyond, then take the second last index anyway
	    // We use our previous result from last calculation (#LastYi) as startpoint for the search
	    #Yindex_L := #LastYi;
	    IF #Yindex_L > 0 AND #y < #Y_Array[#Yindex_L] THEN
	        //Suche nach links (kleinere indizes)
	        WHILE #Yindex_L > 0 AND #y < #Y_Array[#Yindex_L - 1] DO
	            #Yindex_L -= 1;
	            IF #Yindex_L = 0 THEN
	                EXIT;
	            END_IF;
	        END_WHILE;
	    ELSE
	        //Suche nach rechts (größere indizes)
	        WHILE #Yindex_L < (#Count_Yi - 1) AND #y > #Y_Array[#Yindex_L + 1] DO
	            #Yindex_L += 1;
	        END_WHILE;
	    END_IF;
	END_REGION*) //Replaced by "Function"
	#Xindex_U := #Xindex_L +1;
	#Yindex_U := #Yindex_L +1;
	
	REGION interpolation points    
	    // The interpolation points are:
	
	    
	    #X_L := #X_Array[#Xindex_L]; //The largest meshpoint smaller larger than x (< Count_Xi-1)
	    #X_H := #X_Array[#Xindex_U]; //The smalles meshpoint bigger larger than x  (>= 1)
	    #Y_L := #Y_Array[#Yindex_L]; //The largest meshpoint smaller larger than x (< Count_Xi-1)
	    #Y_H := #Y_Array[#Yindex_U]; //The smalles meshpoint bigger larger than x  (>= 1)
	    #F_LxLy := #F_Array[#Xindex_L, #Yindex_L]; // Function value of (X_L,X_L)
	    #F_LxHy := #F_Array[#Xindex_L, #Yindex_U]; // Function value of (X_L,X_H)
	    #F_HxLy := #F_Array[#Xindex_U, #Yindex_L]; // Function value of (X_L,X_L)
	    #F_HxHy := #F_Array[#Xindex_U, #Yindex_U]; // Function value of (X_L,X_H)
	    
	    IF #X_L >= #X_H AND #Y_L >= #Y_H THEN // The lookup has rise strictly monotonously
	        ENO := 1;
	        #f_out := "NaN"();
	        RETURN;
	    END_IF;
	END_REGION
	
	REGION inerpolation
	    //Calculate interpolation with the four meshpoints (X_L,Y_L) (X_H,Y_L) (X_L,Y_H) and (X_H,Y_H)
	    #x:= (#x - #X_L) / (#X_H - #X_L);
	    #y:= (#y - #Y_L) / (#Y_H - #Y_L);
	    #f_out := (#F_HxLy - #F_LxLy) * #x;
	    #f_out += (#F_HxHy - #F_HxLy) * #y;
	    #f_out += (#F_LxHy - #F_LxLy) * #y;
	    #f_out += (#F_HxHy - #F_LxHy) * #x;
	    #f_out /= 2.0;
	    #f_out += #F_LxLy;
	  (*  #f_out :=
	    (#F_HxLy - #F_LxLy) / (#X_H - #X_L) * (#x - #X_L) / 2 +
	    (#F_HxHy - #F_HxLy) / (#Y_H - #Y_L) * (#y - #Y_L) / 2 +
	    (#F_LxHy - #F_LxLy) / (#Y_H - #Y_L) * (#y - #Y_L) / 2 +
	    (#F_HxHy - #F_LxHy) / (#X_H - #X_L) * (#x - #X_L) / 2 +
	    #F_LxLy; *)
	    //There is still an unused information in there, witch can be used for an additional quadratic therm in the direction (X_L,Y_L)->(X_H,Y,H) or right-angled to it. 
	END_REGION
	
	
END_FUNCTION

