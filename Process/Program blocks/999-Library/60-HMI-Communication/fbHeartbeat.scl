FUNCTION_BLOCK "fbHeartbeat"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      bIn : Bool;   // Signal from partner
   END_VAR

   VAR_OUTPUT 
      bOut : Bool;   // Signal to partner
      bOk : Bool;
   END_VAR

   VAR_IN_OUT 
      sTag : "stHeartbeat";
   END_VAR

   VAR 
      Timeout {InstructionName := 'TON_TIME'; LibVersion := '1.0'; S7_SetPoint := 'False'} : TON_TIME;
   END_VAR

   VAR_TEMP 
      In : Bool;
   END_VAR


BEGIN
	// fbHeartbeat - communications monitoring
	// Send a bit back and forth. This side does all the work, the other side just sends back what it has gotten.
	// bOut is set, and waits for bIn to be set before the timeout.
	// Then bOut is cleared and waits for bIn to be cleared before the timeout. 
	
	// Combine local & tag input sources
	#In := #bIn OR #sTag.bIn;
	
	// Timeout
	#Timeout(IN := (#sTag.nState = 2), PT := #sTag.tTimeout);
	
	// States
	CASE #sTag.nState OF
	    0: // Idle
	        #sTag.bOut := FALSE;
	        IF #sTag.bEnable = TRUE THEN
	            #sTag.nState := 1;
	        END_IF;
	    1: // Ping
	        #sTag.bOut := #sTag.bOut XOR TRUE;
	        IF #sTag.bEnable = FALSE THEN
	            #sTag.nState := 0;
	        ELSE
	            #sTag.nState := 2;
	            #sTag.bOk := TRUE;
	        END_IF;
	    2: // Wait
	        IF #In = #sTag.bOut THEN
	            // Pong
	            #sTag.nState := 1;
	        ELSIF #Timeout.Q = TRUE THEN
	            #sTag.nState := 3;
	            #sTag.bOk := FALSE;
	        ELSIF #sTag.bEnable = FALSE THEN
	            #sTag.nState := 0;
	        END_IF;
	    3: // Timeout
	        IF #In = #sTag.bOut THEN
	            #sTag.nState := 1;
	            #sTag.bOk := TRUE;
	        ELSIF #sTag.bEnable = FALSE THEN
	            #sTag.nState := 0;
	        END_IF;
	        
	END_CASE;
	
	// Local outputs
	#bOut := #sTag.bOut;
	#bOk := #sTag.bOk;
	
	
	
END_FUNCTION_BLOCK

