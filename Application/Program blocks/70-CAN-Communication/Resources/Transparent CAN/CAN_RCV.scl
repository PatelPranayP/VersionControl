FUNCTION_BLOCK "CAN_RCV"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      REQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      HW_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;
   END_VAR

   VAR_OUTPUT 
      BUSY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      CAN_STATUS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      NO_FRAMES : SInt;
   END_VAR

   VAR_IN_OUT 
      CAN_FRAMES : "CANFrames";
   END_VAR

   VAR 
      stat_fStart : Bool := TRUE;
      stat_uiRetry : UInt := 0;
      stat_abResponse : Array[0..248] of Byte;
      stat_RDREC {InstructionName := 'RDREC'; LibVersion := '1.0'} : RDREC;
   END_VAR

   VAR_TEMP 
      fBusy : Bool;
      fValid : Bool;
      fError : Bool;
      dwStatus : DWord;
      uiLen : UInt;
      wReturn : Word;
      uiResult : UInt;
      iRetVal : Int;
   END_VAR

   VAR CONSTANT 
      cINDEX_CMD_CAN_RCV : DInt := 16#9B;
      cMLEN_RDREC_CAN_RCV : USInt := 248;
      cMAX_RETRY_CAN_RCV : UInt := 100;
      cMAX_NO_FRAMES_CAN_RCV : Byte := 19;
      cSRC_OFFSET_RESULT_CAN_RCV : DInt := 0;
      cSRC_OFFSET_CANSTATUS_MSB_CAN_RCV : DInt := 1;
      cSRC_OFFSET_CANSTATUS_LSB_CAN_RCV : DInt := 2;
      cSRC_OFFSET_NOFRAMES_CAN_RCV : DInt := 3;
      cSRC_OFFSET_DATA_CAN_RCV : DInt := 4;
      cDEST_INDEX_CAN_RCV : DInt := 0;
   END_VAR


BEGIN
	(* ------------------------------------------------------------------------
	Title:        CAN_RCV
	Description:  function uploads received CAN messages on a
	              CM CANopen module in transparent mode
	              maximum 19 messages are transferred per processed command
	              uploaded CAN frames are copied to the InOut parameter: CAN_FRAMES
	              
	Inputs:       REQ:             TRUE : process CAN_RCV
	                               FALSE: do not process CAN_RCV
	                                      initializes the function
	              HW_ID:           hardware identifier of the CM module
	              
	InOut:        CAN_FRAMES:      pointer to the destination area where to save the
	                               uploaded CAN frames
	
	Outputs:      BUSY:            TRUE : function is running
	                               FALSE: function has been processed: success or error
	              RET:             result of the processed command
	                               see description of output RET of CAN_RCV in the manual
	                               only valid if output BUSY is FALSE
	              CAN_STATUS:      CAN status:
	                               bit coded:
	                                 - bit  0 set: Bus off
	                                 - bit  1 set: error passive
	                                 - bit  2 set: receive queue: full
	                                 - bit  3 set: receive queue: half full
	                                 - bit  4 set: receive queue: warning limit reached
	                                 - bit  5 set: receive message lost
	                                 - bit  6 set: transmit queue: half full
	                                 - bit  7 set: transmit queue: warning limit reached
	                                 - bit 8 - 14: not used
	                                 - bit 15 set: valid
	                               CAN_STATUS is only valid if bit 15 is set:
	                               CAN_STATUS = 16#8000 <=> no error
	              NO_FRAMES:       number of uploaded CAN frames
	                               only valid if
	                                             output BUSY is FALSE
	                                             and output RET does not report an error 
	
	Hint:         - CAN messages must not be lost !!!
	                - function needs minimum 1 call before the response is available
	                  - delay time caused by the CM module:
	                    - time between reception and response: < 1ms
	                  - the more serious delay is caused by the asynchronous processing of
	                    the telegram whose transmission is requested by RDREC
	                    
	                - the frequency of the calls of "CAN_RCV"() is decisive !!!                     
	                - the frequency of the function call must guarantee that CAN
	                  frames are not lost
	
	
	Author:       HMS
	Version:      1.0
	Date:         2017-03-19
	------------------------------------------------------------------------- *)
	
	//==============================================================================
	// layout of the received byte stream:
	// - response of the accessed CM module to a CAN_RCV access
	//==============================================================================
	// - result reported by the CM module
	//     - stat_abResponse[0]
	// - CAN status
	//     - MSB <=> stat_abResponse[1]
	//     - LSB <=> stat_abResponse[2]
	//     only MSB transfers information
	// - number of uploaded CAN frames
	//     - stat_abResponse[3]
	// - uploaded CAN frames
	//     - stat_abResponse[4...]
	//       - each frames covers 12 bytes
	//           CAN-Id         : 2 bytes
	//           RTR            : 1 byte
	//           Data Size / DLC: 1 byte
	//           Data           : 8 bytes
	//       - 1. CAN frame
	//            stat_abResponse[4...15]
	//       - n. CAN frame
	//            stat_abResponse[4 + (n-1) * 12] ... stat_abResponse[4 + (n-1) * 12 + 15]
	
	//       maximum 19 CAN frames can be uploaded per processed CAN_RCV
	//==============================================================================
	
	//==============================================================================
	// init outputs
	// - to avoid misunderstanding
	//==============================================================================
	#RET := 0;
	#CAN_STATUS := 0;
	#NO_FRAMES := 0;
	
	//==============================================================================
	// check if command must be processed
	//==============================================================================
	IF #REQ = FALSE THEN
	    ///////////////////////////////////////////////////
	    // do not process CAN_RCV
	    // initialize CAN_RCV
	    ///////////////////////////////////////////////////
	    #stat_uiRetry := 0;
	    #stat_fStart := TRUE;
	    
	    #BUSY := FALSE;
	    RETURN;
	END_IF;
	
	// init Output #BUSY
	#BUSY := TRUE;
	
	//==============================================================================
	// upload CAN frames
	//==============================================================================
	// upload is done by RDREC
	#stat_RDREC(REQ:=#stat_fStart,
	            ID:=#HW_ID,
	            INDEX:=#cINDEX_CMD_CAN_RCV,
	            MLEN:=#cMLEN_RDREC_CAN_RCV,
	            VALID=>#fValid,
	            BUSY=>#fBusy,
	            ERROR=>#fError,
	            STATUS=>#dwStatus,
	            LEN=>#uiLen,
	            RECORD:=#stat_abResponse);
	
	IF #fBusy = TRUE THEN
	    // prevent RDREC to be triggered once more
	    #stat_fStart := FALSE;
	    RETURN;
	END_IF;
	
	//==============================================================================  
	// CAN_RCV command has been processed
	// check result
	//============================================================================== 
	#uiResult := 0;
	#wReturn := DWORD_TO_WORD(SHR(IN := #dwStatus, N := 8)) AND W#16#FFFF;
	
	////////////////////////////////////////////////////////////////
	// check if
	// - RDREC reports "DP slave or module not ready": 16#xx80B5xx
	// - CM module reports "busy": 16#FE
	//////////////////////////////////////////////////////////////// 
	IF (#wReturn = W#16#80B5) OR (#stat_abResponse[#cSRC_OFFSET_RESULT_CAN_RCV] = w#16#FE) THEN
	    #stat_uiRetry := #stat_uiRetry + 1;
	    IF #stat_uiRetry > #cMAX_RETRY_CAN_RCV THEN
	        //Internal error  
	        #uiResult := 16#1013;
	        GOTO CAN_RCV_DONE;
	    ELSE
	        // repeat: REQ input of RDREC must be set to TRUE
	        #stat_fStart := TRUE;
	        RETURN;
	    END_IF;
	ELSE // IF (#wReturn = W#16#80B5)...   
	    // check for failure 
	    IF #fError = TRUE THEN
	        // RDREC has reported a communication error
	        "SendReceiveErrorCode"(wReturn := #wReturn,
	                               bAddErrInfo := 16#00,
	                               uiErrorCode => #uiResult);
	        GOTO CAN_RCV_DONE;
	    ELSIF #stat_abResponse[#cSRC_OFFSET_RESULT_CAN_RCV] > 0 THEN
	        // command was rejected by the CM module
	        "SendReceiveErrorCode"(wReturn := 16#00FF,
	                               bAddErrInfo := #stat_abResponse[#cSRC_OFFSET_RESULT_CAN_RCV],
	                               uiErrorCode => #uiResult);
	        // check if CAN status is available
	        IF #uiLen >= 2 THEN
	            #CAN_STATUS := BYTE_TO_WORD(#stat_abResponse[#cSRC_OFFSET_CANSTATUS_MSB_CAN_RCV]) OR 16#8000;
	        END_IF;
	        GOTO CAN_RCV_DONE;
	    ELSE
	        // no failure is indicated
	        
	        // check if CAN status is available
	        IF #uiLen >= 2 THEN
	            #CAN_STATUS := BYTE_TO_WORD(#stat_abResponse[#cSRC_OFFSET_CANSTATUS_MSB_CAN_RCV]) OR 16#8000;
	        END_IF;
	        
	        // check number of frames in response
	        IF #stat_abResponse[#cSRC_OFFSET_NOFRAMES_CAN_RCV] = 0 THEN
	            // no CAN frames have been uploaded
	            GOTO CAN_RCV_DONE;
	        ELSIF #stat_abResponse[#cSRC_OFFSET_NOFRAMES_CAN_RCV] > #cMAX_NO_FRAMES_CAN_RCV THEN
	            // SW error: maximum 19 CAN frames can be uploaded
	            "SendReceiveErrorCode"(wReturn := 16#0000,
	                                   bAddErrInfo := #stat_abResponse[#cSRC_OFFSET_NOFRAMES_CAN_RCV],
	                                   uiErrorCode => #uiResult);
	            GOTO CAN_RCV_DONE;
	        ELSE
	            // CAN frames have been uploaded
	            GOTO UPDATE_UPLOADED_FRAMES;
	        END_IF;
	    END_IF; // IF #fError = TRUE THEN ELSIF ELSE 
	END_IF; // IF (#wReturn = W#16#80B5) ... THEN  ELSE   
	
	
	//==============================================================================  
	// copy uploaded CAN frames to the destination area
	//==============================================================================
	UPDATE_UPLOADED_FRAMES:
	
	
	IF (#stat_abResponse[#cSRC_OFFSET_NOFRAMES_CAN_RCV] > 0) AND (#stat_abResponse[#cSRC_OFFSET_NOFRAMES_CAN_RCV] <= 19) THEN
	    #NO_FRAMES := BYTE_TO_SINT(#stat_abResponse[#cSRC_OFFSET_NOFRAMES_CAN_RCV]);
	    MOVE_BLK(IN := #stat_abResponse[#cSRC_OFFSET_DATA_CAN_RCV],
	             COUNT := BYTE_TO_USINT(#stat_abResponse[#cSRC_OFFSET_NOFRAMES_CAN_RCV]) * 12,
	             OUT => #CAN_FRAMES.abCANFrames[#cDEST_INDEX_CAN_RCV]);
	    
	ELSE
	    #NO_FRAMES := 0;
	END_IF;
	
	
	//==============================================================================  
	// command has been processed
	//============================================================================== 
	CAN_RCV_DONE:
	// initialize "CAN_RCV"
	#stat_uiRetry := 0;
	#stat_fStart  := TRUE;
	#NO_FRAMES := BYTE_TO_SINT(#stat_abResponse[#cSRC_OFFSET_NOFRAMES_CAN_RCV]);
	
	#RET := #uiResult;
	#BUSY := FALSE;
	
END_FUNCTION_BLOCK

