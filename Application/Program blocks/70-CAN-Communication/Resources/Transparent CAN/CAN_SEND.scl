FUNCTION_BLOCK "CAN_SEND"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      HW_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;
      NO_FRAMES : USInt;
      CAN_FRAMES : "CANFrames";
   END_VAR

   VAR_OUTPUT 
      BUSY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      CAN_STATUS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
   END_VAR

   VAR_IN_OUT 
      REQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR 
      stat_siState : SInt := #cSTATE_INIT_CAN_SEND;
      stat_fStartSFC : Bool := TRUE;
      stat_usiNoFrames : USInt := 0;
      stat_uiRequestTotalSize : UInt := 0;
      stat_uiRetry : UInt := 0;
      stat_abRequest : Array[0..228] of Byte;
      stat_abResponse : Array[0..247] of Byte;
      stat_WRREC {InstructionName := 'WRREC'; LibVersion := '1.1'} : WRREC;
      stat_RDREC {InstructionName := 'RDREC'; LibVersion := '1.0'} : RDREC;
   END_VAR

   VAR_TEMP 
      fBusy : Bool;
      fDoneValid : Bool;
      fError : Bool;
      dwStatus : DWord;
      wReturn : Word;
      uiLen : UInt;
      iRetVal : Int;
      uiResult : UInt;
      diDataLoop : DInt;
      diDataLoopEnd : DInt;
      usiEntry_ByteString : USInt;
      usiOffset : USInt;
   END_VAR

   VAR CONSTANT 
      cSTATE_INIT_CAN_SEND : SInt := 0;
      cSTATE_WRITE_CAN_SEND : SInt := 1;
      cSTATE_READ_CAN_SEND : SInt := 2;
      cINDEX_CMD_CAN_SEND : DInt := 16#9C;
      cMLEN_RDREC_CAN_SEND : USInt := 248;
      cMAX_RETRY_CAN_SEND : UInt := 100;
      cMAX_NO_FRAMES_CAN_SEND : UInt := 19;
      cBYTE_SIZE_CAN_FRAME : USInt := 12;
      cOFFSET_CAN_FRAME_1 : USInt := 1;
      cOFFSET_DLC : USInt := 3;
   END_VAR


BEGIN
	(* ------------------------------------------------------------------------
	Title:        CAN_SEND
	Description:  function downloads CAN messages to the CM CANopen module
	              in transparent mode
	              maximum 19 messages can be transferred per processed command
	
	
	Inputs:       HW_ID:           hardware identifier of the CM module
	              NO_FRAMES:       number of CAN frames to be transferred
	              CAN_FRAMES:      source area where to get the CAN frames to be
	                               transmitted
	              
	InOut:        REQ:             TRUE : process CAN_SEND
	                                      is automatically cleared when the command
	                                      has been processed
	                               FALSE: do not process CAN_SEND
	                                      initializes the function
	
	Outputs:      BUSY:            TRUE : function is running
	                               FALSE: function has been processed: success or error
	              RESULT:          result of the processed command
	                               only valid if output BUSY is FALSE
	              CAN_STATUS:      CAN status:
	                               bit coded:
	                                 - bit  0 set: Bus off
	                                 - bit  1 set: error passive
	                                 - bit  2 set: receive queue: full
	                                 - bit  3 set: receive queue: half full
	                                 - bit  4 set: receive queue: warning limit reached
	                                 - bit  5 set: receive message lost
	                                 - bit  6 set: transmit queue: half full
	                                 - bit  7 set: transmit queue: warning limit reached
	                                 - bit 8 - 14: not used
	                                 - bit 15 set: valid
	                               CAN_STATUS is only valid if bit 15 is set:
	                               CAN_STATUS = 16#8000 <=> no error
	                               
	Hint:         - function needs minimum 2 calls before the response is available
	                  - delay time caused by the CM module:
	                    - time between reception and response: < 1ms
	                  - the more serious delay is caused by the asynchronous processing of
	                    the telegram whose transmission is requested by WRREC and RDREC
	              - cyclic transmission needs a good design by the application
	
	
	Author:       HMS
	Version:      1.0
	Date:         2017-03-19
	------------------------------------------------------------------------- *)
	
	// init Output RESULT
	#RET := 0;
	// init Output CAN_STATUS
	#CAN_STATUS := 0;
	
	IF #REQ = FALSE THEN
	    ///////////////////////////////////////////////////
	    // do not process CAN_SEND
	    // initialize CAN_SEND
	    /////////////////////////////////////////////////// 
	    #stat_uiRetry := 0;
	    #stat_siState := #cSTATE_INIT_CAN_SEND;
	    #BUSY := FALSE;
	    RETURN;
	END_IF;
	
	// init Output BUSY
	#BUSY := TRUE;
	
	
	//==============================================================================  
	// main of "CAN_SEND"()
	//==============================================================================  
	CASE #stat_siState OF
	    // initialize the data of the requested FCN command    
	    #cSTATE_INIT_CAN_SEND:
	        GOTO CAN_SEND_INIT;
	        
	    // transfer the command and its data to the CM module
	    #cSTATE_WRITE_CAN_SEND:
	        GOTO CAN_SEND_TRANSFER_CMD;
	        
	    // read result from the CM module
	    #cSTATE_READ_CAN_SEND:
	        GOTO CAN_SEND_GET_RESULT;
	        
	    ELSE
	        // state is not supported
	        // error code: state error (not defined in the manual)
	        #uiResult := 16#109F;
	        GOTO CAN_SEND_DONE;
	END_CASE;
	
	
	//==============================================================================  
	// initialize CAN_SEND command
	// - especially ask the application for CAN frames to be sent
	//==============================================================================
	CAN_SEND_INIT:
	
	// check number of CAN frames to be sent
	IF #NO_FRAMES = 0 THEN
	    GOTO CAN_SEND_DONE;
	END_IF;
	IF #NO_FRAMES > #cMAX_NO_FRAMES_CAN_SEND THEN
	    #uiResult := 16#109C;
	    GOTO CAN_SEND_DONE;
	END_IF;
	
	// copy CAN frames in byte array that is transferred to the CM module
	MOVE_BLK(IN:=#CAN_FRAMES.abCANFrames[0],
	         COUNT:=#NO_FRAMES * 12,
	         OUT=>#stat_abRequest[#cOFFSET_CAN_FRAME_1]);
	
	// check CAN frames if CAN-IDs and DLC are valid
	// - MSB of CAN-ID: (#cOFFSET_CAN_FRAME_1 + 0 )+ (n * #cBYTE_SIZE_CAN_FRAME); 0 <= n <= NO_FRAMES - 1
	// - LSB of CAN-ID: (#cOFFSET_CAN_FRAME_1 + 1) + (n * #cBYTE_SIZE_CAN_FRAME); 0 <= n <= NO_FRAMES - 1
	// - RTR:           (#cOFFSET_CAN_FRAME_1 + 2) + (n * #cBYTE_SIZE_CAN_FRAME); 0 <= n <= NO_FRAMES - 1
	// - DLC:           (#cOFFSET_CAN_FRAME_1 + 3) + (n * #cBYTE_SIZE_CAN_FRAME); 0 <= n <= NO_FRAMES - 1
	// - Data:          (#cOFFSET_CAN_FRAME_1 + 4...11) + (n * #cBYTE_SIZE_CAN_FRAME); 0 <= n <= NO_FRAMES - 1
	#usiOffset := #cOFFSET_CAN_FRAME_1;
	#diDataLoopEnd := USINT_TO_DINT(#NO_FRAMES) - 1;
	FOR #diDataLoop := 0 TO #diDataLoopEnd DO
	    // only MSB of the CAN-ID and DLC must be checked
	    IF     (#stat_abRequest[#usiOffset] > 16#07)
	        OR (#stat_abRequest[#usiOffset + #cOFFSET_DLC] > 16#08)
	    THEN
	        #uiResult := 16#109D;
	        GOTO CAN_SEND_DONE;
	    ELSE
	        #usiOffset := #usiOffset + #cBYTE_SIZE_CAN_FRAME;
	    END_IF;
	END_FOR;
	
	// update number of CAN frames to be sent and number of data to be transferred 
	#stat_abRequest[0] := USINT_TO_BYTE(#NO_FRAMES);
	#stat_uiRequestTotalSize := 1 + USINT_TO_UINT(#NO_FRAMES) * #cBYTE_SIZE_CAN_FRAME;
	
	// start write command
	#stat_uiRetry := 0;
	#stat_fStartSFC := TRUE;
	#stat_siState := #cSTATE_WRITE_CAN_SEND;
	
	
	//==============================================================================  
	// transfer the CAN frames to the CM module
	//==============================================================================
	CAN_SEND_TRANSFER_CMD:
	#stat_WRREC(REQ:=#stat_fStartSFC,
	            ID:=#HW_ID,
	            INDEX:=#cINDEX_CMD_CAN_SEND,
	            LEN:=#stat_uiRequestTotalSize,
	            DONE=>#fDoneValid,
	            BUSY=>#fBusy,
	            ERROR=>#fError,
	            STATUS=>#dwStatus,
	            RECORD:=#stat_abRequest);
	
	IF #fBusy = TRUE THEN
	    // reset variable to prevent WRREC to be triggered once more
	    #stat_fStartSFC := FALSE;
	    RETURN;
	ELSE
	    IF #fError = FALSE THEN
	        // seems no error occured, continue with read response
	        #stat_uiRetry := 0;
	        #stat_fStartSFC := TRUE;
	        #stat_siState := #cSTATE_READ_CAN_SEND;
	    ELSE
	        //Write error
	        #wReturn := DWORD_TO_WORD(SHR(IN := #dwStatus, N := 8)) AND W#16#FFFF;
	        "SendReceiveErrorCode"(wReturn := #wReturn,
	                               bAddErrInfo := 16#00,
	                               uiErrorCode => #uiResult);
	        GOTO CAN_SEND_DONE;
	    END_IF;
	END_IF; // IF #fBusy = FALSE THEN 
	
	
	//==============================================================================  
	// get the result from the CM module
	//==============================================================================
	CAN_SEND_GET_RESULT:
	#stat_RDREC(REQ:=#stat_fStartSFC,
	            ID:=#HW_ID,
	            INDEX:=#cINDEX_CMD_CAN_SEND,
	            MLEN:=#cMLEN_RDREC_CAN_SEND,
	            VALID=>#fDoneValid,
	            BUSY=>#fBusy,
	            ERROR=>#fError,
	            STATUS=>#dwStatus,
	            LEN=>#uiLen,
	            RECORD:=#stat_abResponse);
	
	IF #fBusy = TRUE THEN
	    // reset variable to prevent RDREC to be triggered once more
	    #stat_fStartSFC := FALSE;
	    RETURN;
	ELSE  
	      
	    #wReturn := DWORD_TO_WORD(SHR(IN:=#dwStatus,N:=8)) AND W#16#FFFF;
	
	    // check if
	    // - RDREC reports "DP slave or module not ready": 16#xx80B5xx
	    // - CM module repots "busy": 16#FE
	    IF (#wReturn = W#16#80B5) OR (#stat_abResponse[0] = w#16#FE) THEN
	        #stat_uiRetry := #stat_uiRetry + 1;
	        IF #stat_uiRetry > #cMAX_RETRY_CAN_SEND THEN
	            //Internal error  
	            #uiResult := 16#1013;
	            GOTO CAN_SEND_DONE;
	        ELSE
	            // repeat: REQ input of RDREC must be set to TRUE
	            #stat_fStartSFC := TRUE;
	            RETURN;
	        END_IF;
	    ELSE
	      // check for failure 
	      IF #fError = TRUE THEN
	          // RDREC has reported a communication error
	          "SendReceiveErrorCode"(wReturn:=#wReturn,
	                                 bAddErrInfo:=16#00,
	                                 uiErrorCode=>#uiResult);
	      ELSIF #stat_abResponse[0] > 0 THEN
	          // command was rejected by the CM module
	          "SendReceiveErrorCode"(wReturn:=16#00FF,
	                                 bAddErrInfo:=#stat_abResponse[0],
	                                 uiErrorCode=>#uiResult);
	          // check if CAN status is available
	          IF #uiLen >= 2 THEN
	              #CAN_STATUS := BYTE_TO_WORD(#stat_abResponse[1]) OR 16#8000;
	          END_IF;
	      ELSE
	          // success
	          #uiResult := 0;
	          // check if CAN status is available
	          IF #uiLen >= 2 THEN
	              #CAN_STATUS := BYTE_TO_WORD(#stat_abResponse[1]) OR 16#8000;
	          END_IF;
	      END_IF; // IF #fError = TRUE THEN  ELSIF  ELSE
	  END_IF;   // IF (#wReturn = W#16#80B5) ... THEN  ELSE   
	END_IF;     // IF #fBusy = TRUE ELSE THEN
	
	
	//==============================================================================  
	// command has been processed
	//==============================================================================
	CAN_SEND_DONE:
	// initialize "CAN_SEND"()    
	#stat_uiRetry := 0;
	#stat_siState := #cSTATE_INIT_CAN_SEND;
	
	// update outputs
	#RET := #uiResult;
	#BUSY := FALSE;
	
	// clear request at InOut
	#REQ := FALSE;
	
	
END_FUNCTION_BLOCK

